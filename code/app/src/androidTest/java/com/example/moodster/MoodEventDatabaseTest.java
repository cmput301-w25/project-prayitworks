package com.example.moodster;

import android.content.Context;
import android.net.Uri;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;

import com.google.firebase.Timestamp;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.List;

import static org.junit.Assert.*;

@RunWith(AndroidJUnit4.class)
public class MoodEventDatabaseTest {

    private MoodEventViewModel viewModel;
    private Context appContext;

    @Before
    public void setUp() {
        // Retrieve the application context for Firebase and related operations.
        appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
        viewModel = MoodEventViewModel.getInstance();
        viewModel.setContext(appContext);
        // Clear any previously stored events to ensure a clean test environment.
        viewModel.getMoodEvents().clear();
    }

    // 1. Directly add a MoodEvent with a non-zero ID.
    @Test
    public void testAddMoodEventDirect() {
        int id = 1;
        Timestamp now = Timestamp.now();
        String emotionalState = "Happiness";
        String trigger = "Direct add test";
        String socialSituation = "Alone";
        String explanation = "Direct test event";

        MoodEvent event = new MoodEvent(id, now, emotionalState, trigger, socialSituation, explanation, null, 0, 0);
        viewModel.addMoodEvent(event);

        assertTrue("Local store should contain event with id 1", viewModel.getMoodEvents().containsKey(id));
        MoodEvent storedEvent = viewModel.getMoodEvents().get(id);
        assertNotNull("Stored event should not be null", storedEvent);
        assertEquals("Emotional state should match", emotionalState, storedEvent.getEmotionalState());
    }

    // 2. Add a MoodEvent with id=0 to trigger auto-generation.
    @Test
    public void testAddMoodEventAutoGeneratedId() {
        int initialSize = viewModel.getMoodEvents().size();
        Timestamp now = Timestamp.now();
        String emotionalState = "Sadness";
        String trigger = "Auto id test";
        String socialSituation = "With two to several people";
        String explanation = "Auto generated id event";

        MoodEvent event = new MoodEvent(0, now, emotionalState, trigger, socialSituation, explanation, null, 0, 0);
        viewModel.addMoodEvent(event);

        int newSize = viewModel.getMoodEvents().size();
        assertEquals("Local store size should increase by 1", initialSize + 1, newSize);

        // Since the event's original id is 0, check that a non‚Äëzero key was used.
        boolean autoIdUsed = false;
        for (Integer key : viewModel.getMoodEvents().keySet()) {
            if (key != 0) {
                autoIdUsed = true;
                break;
            }
        }
        assertTrue("An auto-generated id should be used for the event", autoIdUsed);
    }

    // 3. Use the overloaded addMoodEvent that accepts a listener.
    @Test
    public void testAddMoodEventWithListener() {
        final boolean[] callbackCalled = {false};
        viewModel.addMoodEvent("Confusion", "Listener test", "Alone", "Testing listener",
                null, 0, 0, new MoodEventViewModel.OnAddListener() {
                    @Override
                    public void onAddSuccess() {
                        callbackCalled[0] = true;
                    }
                    @Override
                    public void onAddFailure(String errorMessage) {
                        // No-op
                    }
                });
        // Since no user is signed in, the listener should not be called.
        assertFalse("Listener should not be called when no user is logged in", callbackCalled[0]);
        // Also, verify that the event was added locally.
        assertTrue("Local store should have at least one event", viewModel.getMoodEvents().size() > 0);
    }

    // 4. Fetch moods when no user is signed in (should return local data synchronously).
    @Test
    public void testFetchCurrentUserMoods() {
        int id = 2;
        Timestamp now = Timestamp.now();
        MoodEvent event = new MoodEvent(id, now, "Anger", "Fetch test", "With crowd", "Fetch test event", null, 0, 0);
        viewModel.addMoodEvent(event);

        final List<MoodEvent>[] fetchedEvents = new List[1];
        viewModel.fetchCurrentUserMoods(new MoodEventViewModel.OnMoodsFetchedListener() {
            @Override
            public void onMoodsFetched(List<MoodEvent> moodEvents) {
                fetchedEvents[0] = moodEvents;
            }
        });
        assertNotNull("Fetched events should not be null", fetchedEvents[0]);
        boolean containsTestEvent = false;
        for (MoodEvent me : fetchedEvents[0]) {
            if ("Anger".equals(me.getEmotionalState())) {
                containsTestEvent = true;
                break;
            }
        }
        assertTrue("Fetched events should contain the added test event", containsTestEvent);
    }

    // 5. Test filtering by explanation returns correct results.
    @Test
    public void testFilterByExplanation() {
        int id1 = 3;
        Timestamp now = Timestamp.now();
        MoodEvent event1 = new MoodEvent(id1, now, "Disgust", "Filter test", "Alone", "Bad experience", null, 0, 0);
        int id2 = 4;
        MoodEvent event2 = new MoodEvent(id2, now, "Fear", "Filter test", "With one other person", "Scary event", null, 0, 0);
        viewModel.addMoodEvent(event1);
        viewModel.addMoodEvent(event2);

        List<MoodEvent> localEvents = new ArrayList<>(viewModel.getMoodEvents().values());
        List<MoodEvent> filtered = MoodEventFilter.filterByExplanation(localEvents, "bad");
        assertFalse("Filtered list should not be empty", filtered.isEmpty());
        assertEquals("There should be one matching event", 1, filtered.size());
        assertEquals("The event explanation should be 'Bad experience'", "Bad experience", filtered.get(0).getExplanation());
    }

    // 6. Test that creating a MoodEvent with an invalid emotional state throws an exception.
    @Test(expected = IllegalArgumentException.class)
    public void testInvalidEmotionalState() {
        Timestamp now = Timestamp.now();
        new MoodEvent(10, now, "InvalidState", "trigger", "social", "explanation", null, 0, 0);
    }

    // 7. Verify that getEmoji returns the expected emoji for each valid emotional state.
    @Test
    public void testGetEmojiForValidEmotionalStates() {
        Timestamp now = Timestamp.now();
        String[][] mapping = {
                {"Anger", "üò°"},
                {"Confusion", "üòµ‚Äçüí´"},
                {"Disgust", "ü§¢"},
                {"Fear", "üò®"},
                {"Happiness", "üòÅ"},
                {"Sadness", "üòì"},
                {"Shame", "üò∂‚Äçüå´Ô∏è"},
                {"Surprise", "üòÆ"}
        };
        int baseId = 100;
        for (int i = 0; i < mapping.length; i++) {
            String state = mapping[i][0];
            String expectedEmoji = mapping[i][1];
            MoodEvent event = new MoodEvent(baseId + i, now, state, "trigger", "social", "explanation", null, 0, 0);
            assertEquals("Emoji for state " + state, expectedEmoji, event.getEmoji());
        }
    }

    // 8. Test adding a MoodEvent with a negative ID to ensure auto-generation is triggered.
    @Test
    public void testAddMoodEventNegativeId() {
        int initialSize = viewModel.getMoodEvents().size();
        Timestamp now = Timestamp.now();
        MoodEvent event = new MoodEvent(-5, now, "Sadness", "trigger", "social", "negative id", null, 0, 0);
        viewModel.addMoodEvent(event);
        int newSize = viewModel.getMoodEvents().size();
        assertEquals("Local store size should increase by 1", initialSize + 1, newSize);

        boolean autoIdUsed = false;
        for (Integer key : viewModel.getMoodEvents().keySet()) {
            if (key != -5) {
                autoIdUsed = true;
                break;
            }
        }
        assertTrue("An auto-generated id should be used for negative id event", autoIdUsed);
    }

    // 9. Test adding a MoodEvent with a non-null image URI.
    @Test
    public void testAddMoodEventWithImageUri() {
        int id = 12;
        Timestamp now = Timestamp.now();
        Uri imageUri = Uri.parse("http://example.com/image.png");
        MoodEvent event = new MoodEvent(id, now, "Fear", "trigger", "social", "with image", imageUri, 0, 0);
        viewModel.addMoodEvent(event);
        MoodEvent storedEvent = viewModel.getMoodEvents().get(id);
        assertNotNull("Stored event should not be null", storedEvent);
        assertNotNull("Image URI should be stored", storedEvent.getImage());
        assertEquals("Stored image URI should match", imageUri, storedEvent.getImage());
    }

    // 10. Test filtering by explanation when no events match the given keyword.
    @Test
    public void testFilterByExplanationNoMatch() {
        int id = 13;
        Timestamp now = Timestamp.now();
        MoodEvent event = new MoodEvent(id, now, "Surprise", "trigger", "social", "unique explanation", null, 0, 0);
        viewModel.addMoodEvent(event);
        List<MoodEvent> localEvents = new ArrayList<>(viewModel.getMoodEvents().values());
        List<MoodEvent> filtered = MoodEventFilter.filterByExplanation(localEvents, "nonexistent");
        assertTrue("Filtered list should be empty for no match", filtered.isEmpty());
    }

    // 11. Test filtering by explanation using an empty or null keyword returns the full list.
    @Test
    public void testFilterByExplanationWithEmptyKeyword() {
        int id1 = 14;
        int id2 = 15;
        Timestamp now = Timestamp.now();
        MoodEvent event1 = new MoodEvent(id1, now, "Happiness", "trigger", "social", "explanation one", null, 0, 0);
        MoodEvent event2 = new MoodEvent(id2, now, "Anger", "trigger", "social", "explanation two", null, 0, 0);
        viewModel.addMoodEvent(event1);
        viewModel.addMoodEvent(event2);
        List<MoodEvent> localEvents = new ArrayList<>(viewModel.getMoodEvents().values());
        List<MoodEvent> filteredNull = MoodEventFilter.filterByExplanation(localEvents, null);
        List<MoodEvent> filteredEmpty = MoodEventFilter.filterByExplanation(localEvents, "   ");
        assertEquals("Filtering with null should return full list", localEvents.size(), filteredNull.size());
        assertEquals("Filtering with empty should return full list", localEvents.size(), filteredEmpty.size());
    }

    // 12. Test adding multiple events consecutively and then fetching them.
    @Test
    public void testMultipleAddAndFetch() {
        int initialSize = viewModel.getMoodEvents().size();
        // Add 5 events.
        for (int i = 0; i < 5; i++) {
            Timestamp now = Timestamp.now();
            MoodEvent event = new MoodEvent(0, now, "Disgust", "trigger" + i, "social", "event " + i, null, 0, 0);
            viewModel.addMoodEvent(event);
        }
        int newSize = viewModel.getMoodEvents().size();
        assertEquals("Local store should increase by 5", initialSize + 5, newSize);
        final List<MoodEvent>[] fetchedEvents = new List[1];
        viewModel.fetchCurrentUserMoods(new MoodEventViewModel.OnMoodsFetchedListener() {
            @Override
            public void onMoodsFetched(List<MoodEvent> moodEvents) {
                fetchedEvents[0] = moodEvents;
            }
        });
        assertNotNull("Fetched events should not be null", fetchedEvents[0]);
        assertEquals("Fetched events count should match local store", newSize, fetchedEvents[0].size());
    }

    // 13. Test that clearing the local store removes all MoodEvents.
    @Test
    public void testClearMoodEvents() {
        int id = 16;
        Timestamp now = Timestamp.now();
        MoodEvent event = new MoodEvent(id, now, "Shame", "trigger", "social", "clear test", null, 0, 0);
        viewModel.addMoodEvent(event);
        assertFalse("Local store should not be empty", viewModel.getMoodEvents().isEmpty());
        viewModel.getMoodEvents().clear();
        assertTrue("Local store should be empty after clearing", viewModel.getMoodEvents().isEmpty());
    }

    // 14. Test consecutive calls to addMoodEvent with listener add separate events.
    @Test
    public void testConsecutiveAddMoodEventsWithListener() {
        int initialSize = viewModel.getMoodEvents().size();
        final int[] successCount = {0};
        viewModel.addMoodEvent("Happiness", "Listener test 1", "Alone", "First event",
                null, 0, 0, new MoodEventViewModel.OnAddListener() {
                    @Override
                    public void onAddSuccess() {
                        successCount[0]++;
                    }
                    @Override
                    public void onAddFailure(String errorMessage) {
                    }
                });
        viewModel.addMoodEvent("Fear", "Listener test 2", "With crowd", "Second event",
                null, 0, 0, new MoodEventViewModel.OnAddListener() {
                    @Override
                    public void onAddSuccess() {
                        successCount[0]++;
                    }
                    @Override
                    public void onAddFailure(String errorMessage) {
                    }
                });
        int newSize = viewModel.getMoodEvents().size();
        assertEquals("Local store should increase by 2", initialSize + 2, newSize);
        // In this environment the listener callbacks are not expected.
        assertEquals("Listener success count should be 0", 0, successCount[0]);
    }
}
